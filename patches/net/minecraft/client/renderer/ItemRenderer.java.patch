--- a/net/minecraft/client/renderer/ItemRenderer.java
+++ b/net/minecraft/client/renderer/ItemRenderer.java
@@ -2,12 +2,19 @@
 
 import com.google.common.base.MoreObjects;
 import java.util.Objects;
+
+import javax.annotation.Nullable;
+
 import net.minecraft.block.Block;
+import net.minecraft.block.BlockLiquid;
 import net.minecraft.block.material.Material;
+import net.minecraft.block.material.MaterialLiquid;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.Minecraft;
+import net.minecraft.client.Minecraft.renderPass;
 import net.minecraft.client.entity.AbstractClientPlayer;
 import net.minecraft.client.entity.EntityPlayerSP;
+import net.minecraft.client.gui.ScaledResolution;
 import net.minecraft.client.renderer.block.model.ItemCameraTransforms;
 import net.minecraft.client.renderer.entity.Render;
 import net.minecraft.client.renderer.entity.RenderManager;
@@ -16,11 +23,26 @@
 import net.minecraft.client.renderer.texture.TextureMap;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.entity.item.EntityBoat;
 import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.init.Blocks;
 import net.minecraft.init.Items;
+import net.minecraft.init.MobEffects;
+import net.minecraft.item.EnumAction;
 import net.minecraft.item.Item;
+import net.minecraft.item.ItemArrow;
+import net.minecraft.item.ItemBlock;
+import net.minecraft.item.ItemBow;
+import net.minecraft.item.ItemCarrotOnAStick;
+import net.minecraft.item.ItemFishingRod;
+import net.minecraft.item.ItemFlintAndSteel;
+import net.minecraft.item.ItemHoe;
 import net.minecraft.item.ItemMap;
+import net.minecraft.item.ItemShears;
+import net.minecraft.item.ItemShield;
 import net.minecraft.item.ItemStack;
+import net.minecraft.item.ItemSword;
+import net.minecraft.item.ItemTool;
 import net.minecraft.src.Config;
 import net.minecraft.src.DynamicLights;
 import net.minecraft.src.Reflector;
@@ -31,9 +53,17 @@
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
+import net.minecraft.util.math.Vec3d;
 import net.minecraft.world.storage.MapData;
 import shadersmod.client.Shaders;
 
+import com.mtbs3d.minecrift.gameplay.BowTracker;
+import com.mtbs3d.minecrift.provider.MCOpenVR;
+import com.mtbs3d.minecrift.render.OpenGLdebugging;
+import com.mtbs3d.minecrift.render.RenderVRPlayer;
+
+import de.fruitfly.ovr.structs.Vector3f;
+
 public class ItemRenderer
 {
     private static final ResourceLocation RES_MAP_BACKGROUND = new ResourceLocation("textures/map/map_background.png");
@@ -49,20 +79,34 @@
     private float prevEquippedProgressOffHand;
     private final RenderManager renderManager;
     private final RenderItem itemRenderer;
-
+    private RenderVRPlayer myRenderVRPlayer;
+    
+    public float getEquipProgress(EnumHand hand, float partialTicks){
+    	if(hand == EnumHand.MAIN_HAND)
+    		return 1.0f- (this.prevEquippedProgressMainHand + (this.equippedProgressMainHand - this.prevEquippedProgressMainHand) * partialTicks);
+    	else
+    		return 1.0F - (this.prevEquippedProgressOffHand + (this.equippedProgressOffHand - this.prevEquippedProgressOffHand) * partialTicks);
+    }
+    
     public ItemRenderer(Minecraft mcIn)
     {
         this.mc = mcIn;
         this.renderManager = mcIn.getRenderManager();
         this.itemRenderer = mcIn.getRenderItem();
+        myRenderVRPlayer = new RenderVRPlayer(this.renderManager);
     }
 
     public void renderItem(EntityLivingBase entityIn, ItemStack heldStack, ItemCameraTransforms.TransformType transform)
     {
-        this.renderItemSide(entityIn, heldStack, transform, false);
+        this.renderItemSide(0,entityIn, heldStack, transform, false);
+    }
+    
+    public void renderItemSide(EntityLivingBase entityIn, ItemStack heldStack, ItemCameraTransforms.TransformType transform, boolean rightSide)
+    {
+        this.renderItemSide(0,entityIn, heldStack, transform, rightSide);
     }
 
-    public void renderItemSide(EntityLivingBase entitylivingbaseIn, ItemStack heldStack, ItemCameraTransforms.TransformType transform, boolean leftHanded)
+    public void renderItemSide(float par1, EntityLivingBase entitylivingbaseIn, ItemStack heldStack, ItemCameraTransforms.TransformType transform, boolean rightSide)    
     {
         if (!heldStack.isEmpty())
         {
@@ -71,17 +115,17 @@
             GlStateManager.pushMatrix();
             boolean flag = this.itemRenderer.shouldRenderItemIn3D(heldStack) && block.getBlockLayer() == BlockRenderLayer.TRANSLUCENT;
 
-            if (flag && (!Config.isShaders() || !Shaders.renderItemKeepDepthMask))
-            {
-                GlStateManager.depthMask(false);
-            }
-
-            this.itemRenderer.renderItem(heldStack, entitylivingbaseIn, transform, leftHanded);
-
-            if (flag)
-            {
-                GlStateManager.depthMask(true);
-            }
+//            if (flag)
+//            {
+//                GlStateManager.depthMask(false);
+//            }
+
+            this.itemRenderer.renderItem(par1, heldStack, entitylivingbaseIn, transform, rightSide);
+
+//            if (flag)
+//            {
+//                GlStateManager.depthMask(true);
+//            }
 
             GlStateManager.popMatrix();
         }
@@ -99,7 +143,7 @@
         GlStateManager.popMatrix();
     }
 
-    private void setLightmap()
+    void setLightmap()
     {
         AbstractClientPlayer abstractclientplayer = this.mc.player;
         int i = this.mc.world.getCombinedLight(new BlockPos(abstractclientplayer.posX, abstractclientplayer.posY + (double)abstractclientplayer.getEyeHeight(), abstractclientplayer.posZ), 0);
@@ -114,6 +158,7 @@
         OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, f, f1);
     }
 
+    //unused
     private void rotateArm(float p_187458_1_)
     {
         EntityPlayerSP entityplayersp = this.mc.player;
@@ -134,6 +179,7 @@
         return f;
     }
 
+    //for map only
     private void renderArms()
     {
         if (!this.mc.player.isInvisible())
@@ -148,6 +194,7 @@
         }
     }
 
+    //for map only
     private void renderArm(EnumHandSide p_187455_1_)
     {
         this.mc.getTextureManager().bindTexture(this.mc.player.getLocationSkin());
@@ -204,14 +251,17 @@
         float f = MathHelper.sqrt(p_187463_3_);
         float f1 = -0.2F * MathHelper.sin(p_187463_3_ * (float)Math.PI);
         float f2 = -0.4F * MathHelper.sin(f * (float)Math.PI);
-        GlStateManager.translate(0.0F, -f1 / 2.0F, f2);
+        //GlStateManager.translate(0.0F, -f1 / 2.0F, f2);
         float f3 = this.getMapAngleFromPitch(p_187463_1_);
-        GlStateManager.translate(0.0F, 0.04F + p_187463_2_ * -1.2F + f3 * -0.5F, -0.72F);
-        GlStateManager.rotate(f3 * -85.0F, 1.0F, 0.0F, 0.0F);
-        this.renderArms();
+      //  GlStateManager.translate(0.0F, 0.04F + p_187463_2_ * -1.2F + f3 * -0.5F, -0.72F);
+        //GlStateManager.rotate(f3 * -85.0F, 1.0F, 0.0F, 0.0F);
+       // this.renderArms();
         float f4 = MathHelper.sin(f * (float)Math.PI);
-        GlStateManager.rotate(f4 * 20.0F, 1.0F, 0.0F, 0.0F);
-        GlStateManager.scale(2.0F, 2.0F, 2.0F);
+       // GlStateManager.rotate(f4 * 20.0F, 1.0F, 0.0F, 0.0F);
+        GlStateManager.translate(-f * 0F, 0.225F, -0.5F);
+        GlStateManager.scale(1.5F, 1.5F, 1.5F);
+        GlStateManager.rotate(-30.0F, 1.0F, 0.0F, 0.0F);
+        GlStateManager.rotate(-30.0F*f, 0.0F, 1.0F, 0.0F);
         this.renderMapFirstPerson(this.itemStackMainHand);
     }
 
@@ -379,56 +429,173 @@
      */
     public void renderOverlays(float partialTicks)
     {
+    	inportal = false;
+    	inwater = false;
+    	inblock = false;
+    	onfire = false;
+    	
         GlStateManager.disableAlpha();
-
-        if (this.mc.player.isEntityInsideOpaqueBlock())
+        Vec3d pos = mc.entityRenderer.getEyeRenderPos(mc.currentPass);
+        if (isInsideOpaqueBlock(pos.add(mc.roomScale.getHMDDir_World().scale(0.05)), true))
         {
-            IBlockState iblockstate = this.mc.world.getBlockState(new BlockPos(this.mc.player));
-            BlockPos blockpos = new BlockPos(this.mc.player);
-            EntityPlayer entityplayer = this.mc.player;
+              //  this.renderBlockInHand(partialTicks, this.mc.getBlockRendererDispatcher().getBlockModelShapes().getTexture(iblockstate));
+            	inblock = true;
+        }
 
-            for (int i = 0; i < 8; ++i)
+        if (!this.mc.player.isSpectator())
+        {
+            if (isInsideOfMaterial(pos, Material.WATER) )
             {
-                double d0 = entityplayer.posX + (double)(((float)((i >> 0) % 2) - 0.5F) * entityplayer.width * 0.8F);
-                double d1 = entityplayer.posY + (double)(((float)((i >> 1) % 2) - 0.5F) * 0.1F);
-                double d2 = entityplayer.posZ + (double)(((float)((i >> 2) % 2) - 0.5F) * entityplayer.width * 0.8F);
-                BlockPos blockpos1 = new BlockPos(d0, d1 + (double)entityplayer.getEyeHeight(), d2);
-                IBlockState iblockstate1 = this.mc.world.getBlockState(blockpos1);
-
-                if (iblockstate1.causesSuffocation())
-                {
-                    iblockstate = iblockstate1;
-                    blockpos = blockpos1;
-                }
+            	inwater = true;
+              //  this.renderWaterOverlayTexture(partialTicks);
             }
 
-            if (iblockstate.getRenderType() != EnumBlockRenderType.INVISIBLE)
+            
+            if (this.mc.player.isBurning() && !Reflector.callBoolean(Reflector.ForgeEventFactory_renderFireOverlay, new Object[] {this.mc.player, Float.valueOf(partialTicks)}))
             {
-                Object object = Reflector.getFieldValue(Reflector.RenderBlockOverlayEvent_OverlayType_BLOCK);
-
-                if (!Reflector.callBoolean(Reflector.ForgeEventFactory_renderBlockOverlay, this.mc.player, partialTicks, object, iblockstate, blockpos))
-                {
-                    this.renderBlockInHand(this.mc.getBlockRendererDispatcher().getBlockModelShapes().getTexture(iblockstate));
-                }
+                this.renderFireInFirstPerson();
+                onfire = true;
             }
         }
 
-        if (!this.mc.player.isSpectator())
+		
+        if (!this.mc.player.isPotionActive(MobEffects.NAUSEA))
         {
-            if (this.mc.player.isInsideOfMaterial(Material.WATER) && !Reflector.callBoolean(Reflector.ForgeEventFactory_renderWaterOverlay, this.mc.player, partialTicks))
-            {
-                this.renderWaterOverlayTexture(partialTicks);
-            }
+            float f = this.mc.player.prevTimeInPortal + (this.mc.player.timeInPortal - this.mc.player.prevTimeInPortal) * partialTicks;
 
-            if (this.mc.player.isBurning() && !Reflector.callBoolean(Reflector.ForgeEventFactory_renderFireOverlay, this.mc.player, partialTicks))
+            if (f > 0.0F)
             {
-                this.renderFireInFirstPerson();
+            	inportal = true;
+               // this.renderPortal(f, new ScaledResolution(mc));
             }
         }
+		
+                
+        GlStateManager.enableAlpha();
+    }
 
+    public boolean inwater, inportal, inblock, onfire;
+    public float inBlock = 0;
+    
+    private void renderPortal(float timeInPortal, ScaledResolution scaledRes)
+    {
+        if (timeInPortal < 1.0F)
+        {
+            timeInPortal = timeInPortal * timeInPortal;
+            timeInPortal = timeInPortal * timeInPortal;
+            timeInPortal = timeInPortal * 0.8F + 0.2F;
+        }
+        GlStateManager.enableTexture2D();
+        GlStateManager.disableAlpha();
+        GlStateManager.disableDepth();
+        GlStateManager.enableBlend();
+        GlStateManager.depthMask(false);
+        GlStateManager.tryBlendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
+        GlStateManager.color(1.0F, 1.0F, 1.0F, timeInPortal);
+        System.out.println(timeInPortal);
+        this.mc.getTextureManager().bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
+        TextureAtlasSprite textureatlassprite = this.mc.getBlockRendererDispatcher().getBlockModelShapes().getTexture(Blocks.PORTAL.getDefaultState());
+        Tessellator tessellator = Tessellator.getInstance();
+        BufferBuilder vertexbuffer = tessellator.getBuffer();
+        float f6 = textureatlassprite.getMinU();
+        float f7 = textureatlassprite.getMaxU();
+        float f8 = textureatlassprite.getMinV();
+        float f9 = textureatlassprite.getMaxV();
+        vertexbuffer.begin(7, DefaultVertexFormats.POSITION_TEX);
+        vertexbuffer.pos(-1.0D, -1.0D, -.6D).tex((double)( f6), (double)( f8)).endVertex();
+        vertexbuffer.pos(1.0D, -1.0D, -.6D).tex((double)(f7), (double)( f8)).endVertex();
+        vertexbuffer.pos(1.0D, 1.0D, -.6D).tex((double)(f7), (double)(f9)).endVertex();
+        vertexbuffer.pos(-1.0D, 1.0D, -.6D).tex((double)( f6), (double)(f9)).endVertex();
+        tessellator.draw();
+        GlStateManager.depthMask(true);
+        GlStateManager.enableDepth();
         GlStateManager.enableAlpha();
+        GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
     }
 
+    public boolean isInsideOfMaterial(Vec3d pos, Material materialIn)
+    {
+    	BlockPos blockpos = new BlockPos(pos);
+    	IBlockState iblockstate = mc.world.getBlockState(blockpos);
+    	IBlockState iblockstateup = mc.world.getBlockState(blockpos.up());
+
+    	if (iblockstate.getMaterial() == materialIn)
+    	{
+    		float f = BlockLiquid.getLiquidHeightPercent(iblockstate.getBlock().getMetaFromState(iblockstate)) -0.11111111F;;
+    		if(iblockstateup.getMaterial() != materialIn && materialIn instanceof MaterialLiquid) f+=0.09F;
+    		
+    		//float f1 = (float)(blockpos.getY() + 1) - f;
+    		boolean flag = (pos.y-blockpos.getY()) < (1-f);
+    		return flag;
+    	}
+    	else
+    	{
+    		return false;
+    	}
+    }
+    
+    
+    public boolean isInsideOpaqueBlock(Vec3d in, boolean set)
+    {
+
+    	if (mc.world == null) return false;
+    	BlockPos bp = new BlockPos(in);
+    	
+    	if(mc.world.getBlockState(bp).isOpaqueCube()) {
+    		inBlock = 1;
+    		return true;
+    	}
+    	
+    	if(!set) return false;
+    	inBlock = 0;    	
+    	Vec3d pos = in.addVector(0, 0, 0);
+    	float per = 0;
+    	float buffer = .07f;	
+    	
+    	if((pos.x - Math.floor(pos.x)) < buffer) 
+    	{
+    		per = (float) (pos.x - Math.floor(pos.x));
+        	inBlock = (buffer - per) / buffer; 
+    		if (mc.world.getBlockState(bp.west()).isOpaqueCube()) return true;
+    	}
+    	
+    	if(pos.x - Math.floor(pos.x) > 1-buffer){
+    		per = 1f - (float) (pos.x - Math.floor(pos.x));
+        	inBlock = (buffer - per) / buffer; 
+    		if (mc.world.getBlockState(bp.east()).isOpaqueCube()) return true;
+    	}
+    	
+    	if((pos.y - Math.floor(pos.y)) < buffer) 
+    	{
+    		per = (float) (pos.y - Math.floor(pos.y));
+        	inBlock = (buffer - per) / buffer; 
+    		if (mc.world.getBlockState(bp.down()).isOpaqueCube()) return true;
+    	} 
+    	
+    	if(pos.y - Math.floor(pos.y) > 1-buffer){
+    		per = 1f - (float) (pos.y - Math.floor(pos.y));
+        	inBlock = (buffer - per) / buffer; 
+    		if (mc.world.getBlockState(bp.up()).isOpaqueCube()) return true;
+    	}
+    	
+    	if((pos.z - Math.floor(pos.z)) < buffer) 
+    	{
+    		per = (float) (pos.z - Math.floor(pos.z));
+        	inBlock = (buffer - per) / buffer; 
+    		if (mc.world.getBlockState(bp.north()).isOpaqueCube()) return true;
+    	} 
+    	
+    	if(pos.z - Math.floor(pos.z) > 1-buffer){
+    		per = 1f - (float) (pos.z - Math.floor(pos.z));
+        	inBlock = (buffer - per) / buffer; 
+    		if (mc.world.getBlockState(bp.south()).isOpaqueCube()) return true;
+    	}
+
+    	return false;
+    	
+    }
+
+
     /**
      * Render the block in the player's hand
      */
